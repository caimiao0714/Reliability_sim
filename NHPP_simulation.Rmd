---
title: "Simulate NHPP using R"
author: "Miao Cai^[Department of Epidemiology and Biostatistics, College for Public Health and Social Justice, Saint Louis University. Email: [miao.cai@slu.edu](miao.cai@slu.edu)]"
date: "`r Sys.Date()`"
output:
  bookdown::pdf_document2: 
    number_sections: true
header-include:
  - \usepackage{soul}
bibliography: refs/bib.bib
link-citations: true
linkcolor: blue
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# A few concepts

**Mean function of a point process**: 

$$\Lambda(t) = E(N(t))$$

$\Lambda(t)$ is the expected number of failures through time $t$.

**Rate of Occurence of Failures (ROCOF)**: When $\Lambda$ is differentiable, the ROCOF is:

$$\mu(t) = \frac{d}{dt}\Lambda(t)$$
The ROCOF can be interpreted as the instantaneous rate of change in the expected number of failures.

**Intensity function**: The intensity function of a point process is 

$$\lambda(t) = \lim_{\Delta t \rightarrow 0}\frac{P(N(t, t+\Delta t] \geq 1)}{\Delta t}$$

When there is no simultaneous events, ROCOF is the same as intensity function.

# NHPP and PLP

**Nonhomogeneous Poisson Process (NHPP)**: The NHPP is a Poisson process whose intensity function is non-constant.

**Power law process (PLP)**: When the intensity function of a NHPP is:

$$\lambda(t) = \frac{\beta}{\theta}\bigg(\frac{t}{\theta}\bigg)^{\beta-1}$$
Where $\beta > 0$ and $\theta > 0$, the process is called the power law process (PLP).

Therefore, the mean function $\Lambda(t)$ is the integral of the intensity function:

$$\Lambda(t) = \int_0^t \lambda(t)dt = \int_0^t \frac{\beta}{\theta}\bigg(\frac{t}{\theta}\bigg)^{\beta-1} = \bigg(\frac{t}{\theta}\bigg)^{\beta}$$


# Inverse algorithm to simulate NHPP

The algorithm used in this tutorial is the review provided by @pasupathy2010generating. He mentioned that the earliest inversion technique was devised by @cinlar2013introduction, which was based on a property of NHPP with a continuous expectation function $\Lambda(t)$.

```{theorem, cinlarthm, name="Cinlar's inversion algorithm"}
Let $\Lambda(t)$ be a positive-valued, continuous, nondecreasing function. Then the random variables $T_1, T_2, \cdots$ are event times corresponding to a NHPP with expectation function $\Lambda(t)$ if and only if $\Lambda(T_1), \Lambda(T_2) \cdots$ are the event times corresponding to a HPP with rate one.
```

Theorem \@ref(thm:cinlarthm) can be used to generate failures from a NHPP: First generate event times from a HPP with rate one, then invert $\Lambda()$ to get the event times. Here are the steps/algorithms provided by @pasupathy2010generating to generate NHPP failure times.

(0) Initialize $s = 0$
(1) Generate $u ~ U(0, 1)$
(2) Set $s \leftarrow s - \log(u)$
(3) Set $t \leftarrow \inf \{ \Lambda(v) \geq s \}$
(4) Deliver t
(5) Go to Step (1)

Here the Step (3) is essentially getting the inverse of $\Lambda(v)$ if $\Lambda(v)$ is a continuous function. 

$$
\begin{aligned}
s & = \Lambda(t) = \bigg(\frac{t}{\theta}\bigg)^\beta\\
s^{1/\beta} &= \frac{t}{\theta}\\
\theta \cdot s^{1/\beta} & = t
\end{aligned}
$$

Therefore, the inverse of $s = \Lambda(t)$ is $t = \theta \cdot s^{1/\beta}$



# Simulation using `R`

We don't have to use a loop to iteratively sample as this algorithm does. Instead, we can use a vectorized form in `R` to simulate event times using this algorithm.

## The most straightforward way of simulation - a loop

In this simulation, we randomly set parameters $\beta = 2, \theta = 10$.

```{r}
set.seed(123)
s = 0; N = 6; t = rep(NA_real_, N) #initialization
beta = 2; theta = 10 # random parameters

for (i in 1:N) {
  u = runif(1)
  s = s - log(u)
  t[i] = theta*s^(1/beta)
}

t
```

An arrow plot of these failures would be:

```{r echo=FALSE}
pacman::p_load(tidyverse)
shift_id= rep(1, length(t))
dat = data.frame(shift_id, t)
dat_lim = data.frame(shift_id = shift_id[1], 
                     start_time = 0, end_time = max(t))

dat %>% 
    ggplot(aes(x = t, y = shift_id)) + 
    geom_point(alpha = 1, shape = 4, color = 'red', 
               size = 4) + 
    xlab('Time to event') + 
    scale_y_continuous("shift ID", 
                       labels = as.character(dat_lim$shift_id), 
                       breaks = dat_lim$shift_id)+
    geom_segment(data = dat_lim, 
                 aes(x = start_time, xend = end_time, 
                     y = shift_id, yend = shift_id),
                 arrow = arrow(length = unit(0.2, "cm")),
                 lineend = 'butt') + theme_classic()
```

Since $\beta = 2 > 1$, the reliability of this system is deteriorating. The failures become more and more intense/frequent at the right side of the plot.

## A more efficient way of simulation - vectorized function

```{r}
sim_plp1 = function(mean_n, beta, theta){
  N = rpois(1, mean_n)
  u = runif(N, 0, 1)
  n_logu = -log(u)
  s = cumsum(n_logu)
  Delta_t = theta*s^(1/beta)
  return(Delta_t)
}

set.seed(666)
t1 = sim_plp1(mean_n = 6, beta = 2, theta = 10)
t1
```

```{r echo=FALSE}
shift_id= rep(1, length(t1))
dat = data.frame(shift_id, t1)
dat_lim = data.frame(shift_id = shift_id[1], 
                     start_time = 0, end_time = max(t1))

dat %>% 
    ggplot(aes(x = t1, y = shift_id)) + 
    geom_point(alpha = 1, shape = 4, color = 'red', 
               size = 4) + 
    xlab('Time to event') + 
    scale_y_continuous("shift ID", 
                       labels = as.character(dat_lim$shift_id), 
                       breaks = dat_lim$shift_id)+
    geom_segment(data = dat_lim, 
                 aes(x = start_time, xend = end_time, 
                     y = shift_id, yend = shift_id),
                 arrow = arrow(length = unit(0.2, "cm")),
                 lineend = 'butt') + theme_classic()
```

## Simulating multiple simulations

```{r echo=FALSE}
sim_mul_plp1 = function(n_shift = 20, 
    shift_len_mean = 6, shift_len_sd = 1.5, 
    theta = 10, beta = 2, mean_n = 5){
  #end_time = rnorm(n_shift, shift_len_mean, shift_len_sd)#to be deleted
  t_list = list()
  len_list = list()
  end_time1 = list()

  for (i in 1:n_shift) {
    t_list[[i]] = sim_plp1(mean_n, beta, theta)
    len_list[[i]] = length(t_list[[i]])
    end_time1[[i]] = ifelse(length(t_list[[i]]) == 0, 0, 
                                   max(t_list[[i]]))
  }
  
  event_dat = data.frame(
    shift_id = rep(1:n_shift, unlist(len_list)),
    event_time = Reduce(c, t_list)
  )
  
  start_end_dat = data.frame(
    shift_id = 1:n_shift,
    start_time = rep(0, n_shift),
    end_time = Reduce(c, end_time1)#to be changed
  )
  start_end_dat$end_time[start_end_dat$end_time == 0] =
    mean(start_end_dat$end_time) # deal with no events
  
  return(list(event_dat = event_dat, 
              start_end_dat = start_end_dat, 
              shift_length = unlist(len_list)))
}



plot_events = function(event_dat, start_end_dat, cross_size = 2){
  p = event_dat %>% 
    ggplot(aes(x = event_time, y = shift_id)) + 
    geom_point(alpha = 0.8, shape = 4, color = 'red', size = cross_size) + 
    scale_y_continuous("shift ID", 
                       labels = as.character(start_end_dat$shift_id), 
                       breaks = start_end_dat$shift_id)+
    xlab('Time to event (minutes)') + 
    geom_segment(data = start_end_dat, 
                 aes(x = start_time, xend = end_time, 
                     y = shift_id, yend = shift_id),
                 lineend = 'butt',
                 arrow = arrow(length = unit(0.2, "cm"))) + 
  theme_classic()
  return(p)
}
```


```{r}
df = sim_mul_plp1()
str(df)
```

The plot for these simulated multiple shifts is:

```{r echo=FALSE}
plot_events(df$event_dat, df$start_end_dat)
```



\newpage
# References {-}